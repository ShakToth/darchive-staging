#!/usr/bin/env bash
set -euo pipefail

BASE_URL="http://127.0.0.1:8000"
PAUSE_AT_END=0
REPORT_FILE=""

for arg in "$@"; do
  case "$arg" in
    --pause)
      PAUSE_AT_END=1
      ;;
    --report=*)
      REPORT_FILE="${arg#--report=}"
      ;;
    http://*|https://*)
      BASE_URL="$arg"
      ;;
  esac
done

if [[ -n "$REPORT_FILE" ]]; then
  mkdir -p "$(dirname "$REPORT_FILE")"
  exec > >(tee "$REPORT_FILE") 2>&1
fi

pass_count=0
warn_count=0
fail_count=0

pass() { echo "[PASS] $1"; pass_count=$((pass_count+1)); }
warn() { echo "[WARN] $1"; warn_count=$((warn_count+1)); }
fail() { echo "[FAIL] $1"; fail_count=$((fail_count+1)); }

status_code() {
  curl -sS -o /dev/null -w "%{http_code}" "$1"
}

header_value() {
  local url="$1"
  local header="$2"
  curl -sSI "$url" | awk -F': ' -v h="$header" 'tolower($1)==tolower(h){print $2}' | tr -d '\r' | head -n 1
}

echo "== Dämmerhafen Pentests =="
echo "Target: $BASE_URL"
[[ -n "$REPORT_FILE" ]] && echo "Report: $REPORT_FILE"

# 1) Direkter Zugriff auf interne PHP-Dateien blockiert
code=$(status_code "$BASE_URL/functions.php")
if [[ "$code" == "403" || "$code" == "404" ]]; then pass "Direkter Zugriff auf functions.php ist blockiert ($code)"; else fail "functions.php sollte blockiert sein, war aber $code"; fi

code=$(status_code "$BASE_URL/api/index.php")
if [[ "$code" == "403" ]]; then pass "Direkter Zugriff auf api/index.php ist blockiert ($code)"; else fail "api/index.php sollte 403 liefern, war aber $code"; fi

# 2) Sicherheitsheader Basischeck
xcto=$(header_value "$BASE_URL/index.php" "X-Content-Type-Options")
xfo=$(header_value "$BASE_URL/index.php" "X-Frame-Options")
refp=$(header_value "$BASE_URL/index.php" "Referrer-Policy")

[[ -n "$xcto" ]] && pass "X-Content-Type-Options vorhanden: $xcto" || fail "X-Content-Type-Options fehlt"
[[ -n "$xfo" ]] && pass "X-Frame-Options vorhanden: $xfo" || fail "X-Frame-Options fehlt"
[[ -n "$refp" ]] && pass "Referrer-Policy vorhanden: $refp" || fail "Referrer-Policy fehlt"

csp=$(header_value "$BASE_URL/index.php" "Content-Security-Policy")
if [[ -n "$csp" ]]; then
  pass "Content-Security-Policy vorhanden"
else
  warn "Content-Security-Policy fehlt (XSS-Härtung ausbaufähig)"
fi

# 3) Session-Cookie Flags prüfen
cookie_line=$(curl -sSI "$BASE_URL/index.php" | awk '/^Set-Cookie:/ {print}' | tr -d '\r' | head -n 1)
if echo "$cookie_line" | grep -qi "httponly"; then pass "Session-Cookie enthält HttpOnly"; else fail "Session-Cookie ohne HttpOnly"; fi
if echo "$cookie_line" | grep -qi "samesite=strict"; then pass "Session-Cookie enthält SameSite=Strict"; else warn "Session-Cookie ohne SameSite=Strict"; fi
if echo "$cookie_line" | grep -qi "secure"; then
  pass "Session-Cookie enthält Secure"
else
  warn "Session-Cookie ohne Secure (auf HTTPS-Deployment aktivieren)"
fi

# 4) CSRF und Auth-Schutz API testen
code=$(curl -sS -o /tmp/pentest_upload_resp.json -w "%{http_code}" -X POST "$BASE_URL/api/upload.php")
if [[ "$code" == "403" ]]; then pass "Upload API blockt Request ohne CSRF (403)"; else fail "Upload API ohne CSRF sollte 403 liefern, war $code"; fi

code=$(curl -sS -o /tmp/pentest_aushaenge_resp.json -w "%{http_code}" -X POST "$BASE_URL/api/aushaenge.php" -H 'Content-Type: application/json' --data '{"titel":"x"}')
if [[ "$code" == "403" ]]; then pass "Aushänge API blockt POST ohne CSRF (403)"; else fail "Aushänge POST ohne CSRF sollte 403 liefern, war $code"; fi

# 5) Login-Bruteforce-Rate-Limit smoke test (nur Verhalten)
# Wir senden wiederholt falsche Logins. Erfolg ist, wenn spätestens nach mehreren Versuchen eine Sperr-Meldung erscheint.
lock_msg_count=$(for i in {1..6}; do
  curl -sS -X POST "$BASE_URL/login.php" \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    --data "header_login=1&header_username=test&header_password=falsch&csrf_token=invalid" | grep -ci "CSRF\|Ungültig" || true
done | awk '{s+=$1} END {print s+0}')
if [[ "$lock_msg_count" -ge 1 ]]; then
  pass "Login-Endpunkt reagiert auf fehlerhafte Requests (CSRF/Validierung greift)"
else
  warn "Login-Schutz konnte nicht eindeutig verifiziert werden (manuell prüfen empfohlen)"
fi

echo ""
echo "== Ergebnis =="
echo "PASS: $pass_count"
echo "WARN: $warn_count"
echo "FAIL: $fail_count"

if [[ "$PAUSE_AT_END" -eq 1 ]]; then
  echo ""
  read -r -p "Zum Beenden Enter drücken ..." _
fi

if [[ "$fail_count" -gt 0 ]]; then
  exit 1
fi
